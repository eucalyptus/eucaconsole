/*************************************************************************
 * (c) Copyright 2016 Hewlett Packard Enterprise Development Company LP
 *
 * Redistribution and use of this software in source and binary forms,
 * with or without modification, are permitted provided that the following
 * conditions are met:
 *
 *   Redistributions of source code must retain the above copyright notice,
 *   this list of conditions and the following disclaimer.
 *
 *   Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ************************************************************************/

// Note: This file is generated by a build step -- any changes here may be overwritten.

angular.module('InstancesServiceModule', [])
.factory('InstancesService', ['$http', function ($http) {
    $http.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    return {
        getInstances: function (csrfToken) {
            return $http({
                method: 'POST',
                url: '/instances/json',
                data: 'csrf_token=' + csrfToken,
                headers: {'Content-Type': 'application/x-www-form-urlencoded'}
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        }
    };
}]);

angular.module('ZonesServiceModule', [])
.factory('ZonesService', ['$http', function ($http) {
    $http.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    return {
        getZones: function () {
            return $http({
                method: 'GET',
                url: '/zones/json'
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        }
    };
}]);

angular.module('VPCServiceModule', [])
.factory('VPCService', ['$http', function ($http) {
    $http.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    return {
        getVPCNetworks: function () {
            return $http({
                method: 'GET',
                url: '/vpcnetworks/json'
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        },
        getVPCSubnets: function () {
            return $http({
                method: 'GET',
                url: '/vpcsubnets/json'
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        },
        getVPCSecurityGroups: function () {
            return $http({
                method: 'GET',
                url: '/vpcsecuritygroups/json'
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        }
    };
}]);

angular.module('ELBServiceModule', [])
.factory('ELBService', ['$http', function ($http) {
    $http.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    return {
        createELB: function (csrfToken, values) {
            var data = {
                csrf_token: csrfToken,
                name: values.elbName,
                elb_listener: JSON.stringify(values.listeners),
                vpc_network: values.vpcNetwork.id,
                vpc_subnet: values.vpcSubnets.map(function(val) { return val.id; }),
                securitygroup: values.vpcSecurityGroups.map(function(val) { return val.id; }),
                zone: values.availabilityZones.map(function(val) { return val.id; }),
                cross_zone_enabled: values.crossZoneEnabled,
                ping_protocol: values.pingProtocol,
                ping_port: values.pingPort,
                ping_path: values.pingPath,
                response_timeout: values.responseTimeout,
                time_between_pings: values.timeBetweenPings,
                failures_until_unhealthy: values.failuresUntilUnhealthy,
                passes_until_healthy: values.passesUntilHealthy,
                logging_enabled: values.loggingEnabled,
                bucket_name: values.bucketName,
                bucket_prefix: values.bucketPrefix,
                collection_interval: values.collectionInterval
            };
            return $http({
                method: 'POST',
                url: '/elbs/create',
                data: $.param(data, true),
                headers: {'Content-Type': 'application/x-www-form-urlencoded'}
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        }
    };
}]);

angular.module('ELBWizard', [
    'ngRoute', 'TagEditorModule', 'ELBListenerEditorModule', 'localytics.directives',
    'ELBSecurityPolicyEditorModule', 'ELBCertificateEditorModule', 'ModalModule',
    'InstancesSelectorModule', 'EucaConsoleUtils', 'InstancesServiceModule',
    'ZonesServiceModule', 'VPCServiceModule', 'ELBServiceModule'
])
.directive('elbWizard', function () {
    return {
        restrict: 'A',
        scope: {
            cloudType: '@',
            vpcEnabled: '@',
        },
        controller: ['$scope', function ($scope) {
            var steps = [
                {
                    label: 'General',
                    href: '/elbs/wizard/',
                    vpcOnly: false,
                    complete: false
                },
                {
                    label: 'Network',
                    href: '/elbs/wizard/network',
                    vpcOnly: true,
                    complete: false
                },
                {
                    label: 'Instances',
                    href: '/elbs/wizard/instances',
                    vpcOnly: false,
                    complete: false
                },
                {
                    label: 'Health Check & Advanced',
                    href: '/elbs/wizard/advanced',
                    vpcOnly: false,
                    complete: false
                }
            ];

            this.validSteps = function () {
                var validSteps = steps.filter(function (current) {
                    if($scope.cloudType === 'aws' || $scope.vpcEnabled) {
                        return true;
                    } else {
                        return !current.vpcOnly;
                    }
                });
                return validSteps;
            };
        }],
        controllerAs: 'wizard'
    };
})
.factory('ELBWizardService', ['$location', function ($location) {

    function Navigation (steps) {
        steps = steps || [];
        this.steps = steps.map(function (current, index, ary) {
            current._next = ary[index + 1];
            return current;
        });
        this.current = this.steps[0];
    }

    Navigation.prototype.next = function () {
        this.current = this.current._next;
        return this.current;
    };

    var svc = {
        certsAvailable: [],
        policies: [],
        values: {
            elbName: '',
            listeners: [{
                'fromPort': 80,
                'toPort': 80,
                'fromProtocol': 'HTTP',
                'toProtocol': 'HTTP'
            }],
            tags: [],
            vpcNetwork: 'None',
            vpcNetworkChoices: [],
            vpcSubnets: [],
            vpcSubnetChoices: [],
            vpcSecurityGroups: [],
            vpcSecurityGroupChoices: [],
            instances: [],
            availabilityZones: [],
            availabilityZoneChoices: [],
            pingProtocol: 'HTTP',
            pingPort: 80,
            pingPath: '/',
            responseTimeout: 5,
            timeBetweenPings: '30',
            failuresUntilUnhealthy: '2',
            passesUntilHealthy: '2',
            loggingEnabled: false,
            bucketName: '',
            bucketPrefix: '',
            collectionInterval: '5'
        },

        initNav: function (steps) {
            this.nav = new Navigation(steps);
            return this.nav;
        },

        next: function (params) {
            angular.merge(this.values, params);

            this.nav.current.complete = true;
            var next = this.nav.next();
            $location.path(next.href);
        },

        displaySummary: function(step) {
            if(!this.nav) {
                return;
            }
            return this.nav.steps[step].complete || this.nav.steps[step] === this.nav.current;
        },

        submit: function () {
        }
    };
    return svc;
}])
.directive('stepData', function () {
    return {
        restrict: 'A',
        scope: {
            stepData: '='
        },
        controller: ['$scope', function ($scope) {
            angular.merge(this, $scope.stepData);
        }]
    };
})
.directive('focusOnLoad', function ($timeout) {
    return {
        restrict: 'A',
        link: function (scope, elem) {
            $timeout(function () {
                elem[0].focus();
            });
        }
    };
})
.directive('summaryPane', function() {
    return {
        restrict: 'E',
        templateUrl: '/_template/elbs/wizard/summary',
        controller: ['ELBWizardService', function (ELBWizardService) {
            this.values = ELBWizardService.values;
            this.nav = ELBWizardService.nav;
            this.displaySummary = ELBWizardService.displaySummary;
        }],
        controllerAs: 'summary'
    };
})
.directive('fetchData', function(InstancesService, ZonesService, VPCService, ELBWizardService, eucaHandleError) {
    return {
        restrict: 'E',
        link: function(scope, elem, attrs) {
            if (attrs.isVpc === 'True') {
                // load vpcs, subnets, groups
                VPCService.getVPCNetworks().then(
                    function success(result) {
                        result.forEach(function(val) {
                            ELBWizardService.values.vpcNetworkChoices.push(val); 
                        });
                        ELBWizardService.values.vpcNetwork = ELBWizardService.values.vpcNetworkChoices[0];
                    },
                    function error(errData) {
                        eucaHandleError(errData.data.message, errData.status);
                    });
                VPCService.getVPCSubnets().then(
                    function success(result) {
                        result.forEach(function(val) {
                            val.labelBak = val.label;
                            ELBWizardService.values.vpcSubnetChoices.push(val); 
                        });
                    },
                    function error(errData) {
                        eucaHandleError(errData.data.message, errData.status);
                    });
                VPCService.getVPCSecurityGroups().then(
                    function success(result) {
                        result.forEach(function(val) {
                            ELBWizardService.values.vpcSecurityGroupChoices.push(val);
                            if (val.label === 'default') {
                                ELBWizardService.values.vpcSecurityGroups.push(val);
                            }
                        });
                    },
                    function error(errData) {
                        eucaHandleError(errData.data.message, errData.status);
                    });
            }
            else {
                // load zones
                ZonesService.getZones().then(
                    function success(result) {
                        result.forEach(function(val) {
                            ELBWizardService.values.availabilityZoneChoices.push(val); 
                        });
                    },
                    function error(errData) {
                        eucaHandleError(errData.data.message, errData.status);
                    });
            }
            InstancesService.getInstances($('#csrf_token').val()).then(
                function success(result) {
                    result.forEach(function(val) {
                        ELBWizardService.values.instances.push(val); 
                    });
                },
                function error(errData) {
                    eucaHandleError(errData.data.message, errData.status);
                });
        }
    };
})
.config(function ($routeProvider, $locationProvider) {
    var certificatePromise;

    $routeProvider
        .when('/elbs/wizard/', {
            templateUrl: '/_template/elbs/wizard/general',
            controller: 'GeneralController',
            controllerAs: 'general',
            resolve: {
                policies: function ($q) {
                    return $q.when('foo');
                },
                certificates: ['CertificateService', function (CertificateService) {
                    if(!certificatePromise) {
                        certificatePromise = CertificateService.getCertificates();
                    }
                    return certificatePromise;
                }]
            }
        })
        .when('/elbs/wizard/network', {
            templateUrl: '/_template/elbs/wizard/network',
            controller: 'NetworkController',
            controllerAs: 'network'
        })
        .when('/elbs/wizard/instances', {
            templateUrl: '/_template/elbs/wizard/instances',
            controller: 'InstancesController',
            controllerAs: 'instances'
        })
        .when('/elbs/wizard/advanced', {
            templateUrl: '/_template/elbs/wizard/advanced',
            controller: 'AdvancedController',
            controllerAs: 'advanced'
        });

    $locationProvider.html5Mode(true);
});

angular.module('ELBWizard')
.directive('wizardNav', function () {
    return {
        restrict: 'E',
        require: '?^elbWizard',
        templateUrl: '/_template/elbs/wizard/navigation',
        link: function (scope, element, attributes, ctrl) {
            var steps = ctrl.validSteps();
            scope.setNav(steps);
        },
        controller: ['$scope', '$location', 'ELBWizardService', function ($scope, $location, ELBWizardService) {
            $scope.setNav = function (steps) {
                $scope.navigation = ELBWizardService.initNav(steps);
            };

            this.validSteps = function () {
                return $scope.navigation.steps;
            };

            this.visit = function (step) {
                if(step.complete) {
                    return step.href;
                }
                return '';
            };

            this.status = function (step) {
                var path = $location.path();
                return {
                    active: (path == step.href),
                    disabled: (path != step.href) && !step.complete,
                    complete: step.complete
                };
            };
        }],
        controllerAs: 'nav'
    };
});

angular.module('ELBWizard')
.controller('MainController', function () {
});

angular.module('ELBWizard')
.controller('GeneralController', ['$scope', '$route', '$routeParams', 
        '$location', 'ModalService', 'ELBWizardService', 'certificates', 'policies',
    function ($scope, $route, $routeParams, $location, ModalService, ELBWizardService, certificates, policies) {
        this.stepData = {
            certsAvailable: certificates,
            polices: policies
        };
        ELBWizardService.certsAvailable = certificates;
        ELBWizardService.policies = policies;

        this.values = ELBWizardService.values;

        this.submit = function () {
            if($scope.generalForm.$invalid) {
                return;
            }

            ELBWizardService.next({});
        };

        $scope.$on('$destroy', function () {
            ModalService.unregisterModals('securityPolicyEditor', 'certificateEditor');
        });
    }]);

angular.module('ELBWizard')
.controller('InstancesController', ['$scope', '$routeParams', 'eucaHandleError',
            'ELBWizardService',
    function ($scope, $routeParams, eucaHandleError, ELBWizardService) {
        var vm = this;
        vm.vpcNetwork = ELBWizardService.values.vpcNetwork;
        vm.availabilityZones = ELBWizardService.values.availabilityZones;
        vm.availabilityZoneChoices = ELBWizardService.values.availabilityZoneChoices;
        vm.vpcSubnets = ELBWizardService.values.vpcSubnets;
        vm.vpcSubnetChoices = ELBWizardService.values.vpcSubnetChoices;
        vm.instances = ELBWizardService.values.instances;
        vm.instancesLoading = (ELBWizardService.values.instances === undefined);
        // using $watch instead of ng-change because...
        // https://github.com/leocaseiro/angular-chosen/issues/145
        $scope.$watch('instances.availabilityZones', function(newval, oldval) {
            if (newval === oldval) return;  // leave unless there's a change
            vm.handleDeselection(newval, oldval, 'availability_zone');
        });
        $scope.$watch('instances.vpcSubnets', function(newval, oldval) {
            if (newval === oldval) return;  // leave unless there's a change
            vm.handleDeselection(newval, oldval, 'subnet_id');
        });
        vm.handleDeselection = function(newval, oldval, field) {
            var valDiff = oldval.filter(function(x) {
                var idx = newval.findIndex(function(val) {
                    return val.id === x.id;
                });
                return idx === -1;
            });
            if (valDiff.length === 0) return;  // leave unless there were zone(s) removed
            vm.instances.forEach(function(instance) {
                if (instance.selected !== true) return;  // get out fast if not selected
                var instanceInDeselectedVal = valDiff.some(function(zone) {
                    return (zone.id === instance[field]);
                });
                if (instanceInDeselectedVal) instance.selected = false;
            });
        };
        // may want to make this event-driven by having instance selector use callback upon selection change
        $scope.$watch('instances.instances', function(newval, oldval) {
            if (newval === oldval) return;  // leave unless there's a change
            vm.handleInstanceSelectionChange(newval, oldval);
        }, true);
        vm.handleInstanceSelectionChange = function(newval, oldval) {
            if (vm.vpcNetwork === 'None') {
                // update labels, accumulate zones for selection
                changeSelection(vm.availabilityZoneChoices, 'availability_zone', 'id', vm.availabilityZones);
            } else {
                // update labels, accumulate subnets for selection
                changeSelection(vm.vpcSubnetChoices, 'subnet_id', 'labelBak', vm.vpcSubnets);
            }
        };
        var changeSelection = function(resourceList, instanceField, resourceLabelBase, resultList) {
            resultList.length = 0;
            resourceList.forEach(function (resource) {
                var count = vm.instances.filter(function(instance) {
                    return instance.selected && instance[instanceField] === resource.id;
                }).length;
                resource.label = resource[resourceLabelBase] + " : " + count + " instances";
                if (count > 0) {
                    resultList.push(resource);
                }
            });
        };
        vm.submit = function () {
            if($scope.instanceForm.$invalid) {
                return;
            }
            ELBWizardService.next({
                vpcSubnets: vm.vpcSubnets,
                availabilityZones: vm.availabilityZones,
                instances: vm.instances
            });
        };
    }
]);

angular.module('ELBWizard')
.controller('NetworkController', ['$scope', 'ELBWizardService', function ($scope, ELBWizardService) {
    var vm = this;
    vm.vpcNetwork = ELBWizardService.values.vpcNetwork;
    vm.vpcNetworkChoices = ELBWizardService.values.vpcNetworkChoices;
    vm.vpcSecurityGroups = ELBWizardService.values.vpcSecurityGroups;
    vm.vpcSecurityGroupChoices = ELBWizardService.values.vpcSecurityGroupChoices;

    vm.submit = function () {
        if ($scope.networkForm.$invalid) {
            return;
        }

        ELBWizardService.next({
            vpcNetwork: vm.vpcNetwork,
            vpcSecurityGroups: vm.vpcSecurityGroups
        });
    };
}]);

angular.module('ELBWizard')
.controller('AdvancedController', ['$scope', '$routeParams', 'ELBWizardService', 'ELBService', function ($scope, $routeParams, ELBWizardService, ELBService) {
    this.values = ELBWizardService.values;
    this.createELB = function($event) {
        $event.preventDefault();
        ELBService.createELB($('#csrf_token').val(), this.values).then(
            function success() {
                console.log('created ELB!');
            },
            function failure() {
                console.log('did not ELB!');
            }
        );
    };
}]);


angular.module('ELBListenerEditorModule', ['ModalModule'])
.directive('listenerEditor', function () {
    return {
        restrict: 'E',
        scope: {
            listeners: '=ngModel'
        },
        templateUrl: '/_template/elbs/listener-editor/listener-editor',
        controller: ['$scope', 'ModalService', function ($scope, ModalService) {
            var vm = this;

            this.from = {};
            this.to = {};

            var validPorts = [25, 80, 443, 465, 587],
                validPortMin = 1024,
                validPortMax = 65535;

            this.protocols = [
                {name: 'Select...', value: 'None', port: ''},
                {name: 'HTTP', value: 'HTTP', port: 80},
                {name: 'HTTPS', value: 'HTTPS', port: 443},
                {name: 'TCP', value: 'TCP', port: 80},
                {name: 'SSL', value: 'SSL', port: 443}
            ];

            this.sourceValid = function (source) {
                var validPort = !this.portInUse(source) && !this.portOutOfRange(source);
                var validProtocol = source.protocol !== 'None';

                return (validPort && validProtocol);
            };

            this.targetValid = function (target) {
                var port = Number(target.port);
                var validPort = (port >= 1) && (port <= validPortMax);

                return validPort && target.protocol !== 'None';
            };

            this.portsValid = function () {
                var fromValid = this.sourceValid(vm.from);
                var toValid = this.targetValid(vm.to);

                return fromValid && toValid;
            };

            this.portInUse = function (target) {
                var usedPorts = $scope.listeners.map(function (item) {
                    return item.fromPort;
                });
                return usedPorts.some(function (current) {
                    return Number(target.port) === current;
                });
            };

            this.portOutOfRange = function (target, allowEmpty) {
                if(target.port === undefined && allowEmpty) {
                    return false;
                }

                var port = Number(target.port);
                var validReservedPort = validPorts.some(function (current) {
                    return current === port;
                });
                var validUnreservedPort = (port >= validPortMin) && (port <= validPortMax);

                return !(validReservedPort || validUnreservedPort);
            };

            this.removeListener = function (index) {
                $scope.listeners.splice(index, 1);
            };

            this.addListener = function () {
                if(!vm.portsValid()) {
                    return;
                }

                var listener = {
                    fromPort: vm.from.port,
                    fromProtocol: vm.from.protocol,
                    toPort: vm.to.port,
                    toProtocol: vm.to.protocol
                };
                $scope.listeners.push(listener);

                vm.reset();
            };

            this.reset = function () {
                vm.from = vm.protocols[0];
                vm.to = vm.protocols[0];
            };
            this.cancel = this.reset;

            this.openPolicyModal = function () {
                ModalService.openModal('securityPolicyEditor');
            };

            this.openCertificateModal = function () {
                ModalService.openModal('certificateEditor');
            };
        }],
        controllerAs: 'ctrl'
    };
})
.directive('protocolPort', function () {
    return {
        restrict: 'E',
        require: 'ngModel',
        scope: {
            target: '=ngModel',
            label: '@',
            protocols: '='
        },
        templateUrl: '/_template/elbs/listener-editor/protocol-port',
        link: function (scope, element, attrs, ctrl) {
            //  Custon form-field behavior. Let protocol-port act as a form field.

            var protocolField = element.find('select'),
                portField = element.find('input');

            protocolField.on('change blur', updateViewValue);
            portField.on('change blur', updateViewValue);

            function updateViewValue () {
                var protocol = protocolField.val(),
                    port = portField.val();

                ctrl.$setViewValue({
                    protocol: protocol,
                    port: port
                });

                ctrl.$setTouched();
            }

            ctrl.$render = function () {
                protocolField.val(scope.target.protocol);
                portField.val(scope.target.port);
            };
        },
        controller: ['$scope', function ($scope) {
            this.onUpdate = function (protocol) {
                $scope.port = protocol.port;
            };
        }],
        controllerAs: 'ctrl'
    };
})
.filter('policy', function () {
    return function (input) {
        if(!input) {
            return 'N/A';
        }
    };
})
.filter('certificates', function () {
    return function (input) {
        if(!input) {
            return 'N/A';
        }
    };
});

angular.module('ELBSecurityPolicyEditorModule', ['ModalModule'])
.directive('securityPolicyEditor', function () {
    return {
        restrict: 'E',
        scope: {
            policy: '=ngModel'
        },
        templateUrl: '/_template/elbs/listener-editor/security-policy',
        controller: ['$scope', function ($scope) {
        }]
    };
});

// Allow the module to be pre-defined with additional dependencies
try{
    angular.module('MagicSearch');
} catch (exception) {
    angular.module('MagicSearch', []);
}

angular.module('MagicSearch')
    .directive('magicSearch', function($compile) {
        return {
            restrict: 'E',
            scope: {
                facets_param: '@facets',
                filter_keys: '=filterKeys',
                strings: '=strings'
            },
            templateUrl: function (scope, elem) {
                return elem.template;
            },
            controller: function ($scope, $element, $timeout) {
                var searchInput = $element.find('.search-input');
                $scope.promptString = $scope.strings.prompt;
                $scope.currentSearch = [];
                $scope.initSearch = function() {
                    if (typeof $scope.facets_param === 'string') {
                        // Parse facets JSON and convert to a list of facets.
                        var tmp = $scope.facets_param.replace(/__apos__/g, "\'").replace(/__dquote__/g, '\\"').replace(/__bslash__/g, "\\");
                        $scope.facetsObj = JSON.parse(tmp);
                    }
                    else {
                        // Assume this is a usable javascript object
                        $scope.facetsObj = $scope.facets_param;
                    }
                    $scope.facetsSave = $scope.copyFacets($scope.facetsObj);
                    $scope.initFacets();
                };
                $scope.initFacets = function() {
                    // set facets selected and remove them from facetsObj
                    var initialFacets = window.location.search;
                    if (initialFacets.indexOf('?') === 0) {
                        initialFacets = initialFacets.slice(1);
                    }
                    initialFacets = initialFacets.split('&');
                    if (initialFacets.length > 1 || initialFacets[0].length > 0) {
                        $timeout(function() {
                            $scope.strings.prompt = '';
                        });
                    }
                    angular.forEach(initialFacets, function(facet, idx) {
                        var facetParts = facet.split('=');
                        angular.forEach($scope.facetsObj, function(value, idx) {
                            if (value.name == facetParts[0]) {
                                if (value.options === undefined) {
                                    $scope.currentSearch.push({'name':facet, 'label':[value.label, facetParts[1]]});
                                    // allow free-form facets to remain
                                }
                                else {
                                    angular.forEach(value.options, function(option, idx) {
                                        if (option.key == facetParts[1]) {
                                            $scope.currentSearch.push({'name':facet, 'label':[value.label, option.label]});
                                            if (value.singleton === true) {
                                                $scope.deleteFacetEntirely(facetParts);
                                            }
                                            else {
                                                $scope.deleteFacetSelection(facetParts);
                                            }
                                        }
                                    });
                                }
                            }
                        });
                    });
                    if ($scope.textSearch !== undefined) {
                        $scope.currentSearch.push({'name':'text='+$scope.textSearch, 'label':[$scope.strings.text, $scope.textSearch]});
                    }
                    $scope.filteredObj = $scope.facetsObj;
                };
                $scope.addFacets = function(facets) {
                    // add a facets javascript object to the existing list
                    for (var facet in facets) {
                        $scope.facetsObj.append(facet);
                    }
                };
                $scope.copyFacets = function(facets) {
                    var ret = [];
                    for (var i=0; i<facets.length; i++) {
                        var facet = Object.create(facets[i]);
                        if (facets[i].options !== undefined) {
                            facet.options = [];
                            for (var j=0; j<facets[i].options.length; j++) {
                                facet.options.push(Object.create(facets[i].options[j]));
                            }
                        }
                        ret.push(facet);
                    }
                    return ret;
                };
                $scope.$watch('facets_param', function(newVal, oldVal) {
                    if (newVal === oldVal) return;
                    $scope.currentSearch = [];
                    $scope.initSearch();
                });
                // removes a facet from the menu
                $scope.deleteFacetSelection = function(facetParts) {
                    angular.forEach($scope.facetsObj.slice(), function(facet, idx) {
                        if (facet.name == facetParts[0]) {
                            if (facet.options === undefined) {
                                return;  // allow free-form facets to remain
                            }
                            for (var i=0; i<facet.options.length; i++) {
                                var option = facet.options[i];
                                if (option.key == facetParts[1]) {
                                    $scope.facetsObj[idx].options.splice($scope.facetsObj[idx].options.indexOf(option), 1);
                                }
                            }
                            if (facet.options.length === 0) {
                                $scope.facetsObj.splice($scope.facetsObj.indexOf(facet), 1);
                            }
                        }
                    });
                };
                $scope.deleteFacetEntirely = function(facetParts) {
                    // remove entire facet
                    angular.forEach($scope.facetsObj.slice(), function(facet, idx) {
                        if (facet.name == facetParts[0]) {
                            $scope.facetsObj.splice($scope.facetsObj.indexOf(facet), 1);
                        }
                    });
                };
                searchInput.on('keydown', function($event) {
                    var key = $event.keyCode || $event.charCode;
                    if (key == 9) {  // prevent default when we can.
                        $event.preventDefault();
                    }
                });
                searchInput.on('keyup', function($event) {  // handle ctrl-char input
                    if ($event.metaKey === true) {
                        return;
                    }
                    var searchVal = searchInput.val();
                    var key = $event.keyCode || $event.charCode;
                    if (key == 9) {  // tab, so select facet if narrowed down to 1
                        if ($scope.facetSelected === undefined) {
                            if ($scope.filteredObj.length != 1) return;
                            $scope.facetClicked(0, '', $scope.filteredObj[0].name);
                        }
                        else {
                            if ($scope.filteredOptions === undefined || $scope.filteredOptions.length != 1) return;
                            $scope.optionClicked(0, '', $scope.filteredOptions[0].key);
                            $scope.resetState();
                        }
                        $timeout(function() {
                            searchInput.val('');
                        });
                        return;
                    }
                    if (key == 27) {  // esc, so cancel and reset everthing
                        $timeout(function() {
                            $scope.hideMenu();
                            searchInput.val('');
                        });
                        $scope.resetState();
                        var textFilter = $scope.textSearch;
                        if (textFilter === undefined) {
                            textFilter = '';
                        }
                        $scope.$emit('textSearch', textFilter, $scope.filter_keys);
                        return;
                    }
                    if (key == 13) {  // enter, so accept value
                        // if tag search, treat as regular facet
                        if ($scope.facetSelected && $scope.facetSelected.options === undefined) {
                            var curr = $scope.facetSelected;
                            curr.name = curr.name + '=' + searchVal;
                            curr.label[1] = searchVal;
                            $scope.currentSearch.push(curr);
                            $scope.resetState();
                            $scope.emitQuery();
                            $scope.showMenu();
                        }
                        // if text search treat as search
                        else {
                            for (i=0; i<$scope.currentSearch.length; i++) {
                                if ($scope.currentSearch[i].name.indexOf('text') === 0) {
                                    $scope.currentSearch.splice(i, 1);
                                }
                            }
                            $scope.currentSearch.push({'name':'text='+searchVal, 'label':[$scope.strings.text, searchVal]});
                            $scope.$apply();
                            $scope.hideMenu();
                            searchInput.val('');
                            $scope.$emit('textSearch', searchVal, $scope.filter_keys);
                            $scope.textSearch = searchVal;
                        }
                        $scope.filteredObj = $scope.facetsObj;
                    }
                    else {
                        if (searchVal === '') {
                            $scope.filteredObj = $scope.facetsObj;
                            $scope.$apply();
                            $scope.$emit('textSearch', '', $scope.filter_keys);
                            if ($scope.facetSelected && $scope.facetSelected.options === undefined) {
                                $scope.resetState();
                            }
                        }
                        else {
                            $scope.filterFacets(searchVal);
                        }
                    }
                });
                searchInput.on('keypress', function($event) {  // handle character input
                    var searchVal = searchInput.val();
                    var key = $event.which || $event.keyCode || $event.charCode;
                    if (key != 8 && key != 46 && key != 13 && key != 9 && key != 27) {
                        searchVal = searchVal + String.fromCharCode(key).toLowerCase();
                    }
                    if (searchVal == ' ') {  // space and field is empty, show menu
                        $scope.showMenu();
                        $timeout(function() {
                            searchInput.val('');
                        });
                        return;
                    }
                    if (searchVal === '') {
                        $scope.filteredObj = $scope.facetsObj;
                        $scope.$apply();
                        $scope.$emit('textSearch', '', $scope.filter_keys);
                        if ($scope.facetSelected && $scope.facetSelected.options === undefined) {
                            $scope.resetState();
                        }
                        return;
                    }
                    if (key != 8 && key != 46) {
                        $scope.filterFacets(searchVal);
                    }
                });
                $scope.filterFacets = function(searchVal) {
                    // try filtering facets/options.. if no facets match, do text search
                    var i, idx, label;
                    var filtered = [];
                    if ($scope.facetSelected === undefined) {
                        $scope.filteredObj = $scope.facetsObj;
                        for (i=0; i<$scope.filteredObj.length; i++) {
                            var facet = $scope.filteredObj[i];
                            idx = facet.label.toLowerCase().indexOf(searchVal);
                            if (idx > -1) {
                                label = [facet.label.substring(0, idx), facet.label.substring(idx, idx + searchVal.length), facet.label.substring(idx + searchVal.length)];
                                filtered.push({'name':facet.name, 'label':label, 'options':facet.options});
                            }
                        }
                        if (filtered.length > 0) {
                            $scope.showMenu();
                            $timeout(function() {
                                $scope.filteredObj = filtered;
                            }, 0.1);
                        }
                        else {
                            $scope.$emit('textSearch', searchVal, $scope.filter_keys);
                            $scope.hideMenu();
                        }
                    }
                    else {  // assume option search
                        $scope.filteredOptions = $scope.facetOptions;
                        if ($scope.facetOptions === undefined) { // no options, assume free form text facet
                            return;
                        }
                        for (i=0; i<$scope.filteredOptions.length; i++) {
                            var option = $scope.filteredOptions[i];
                            idx = option.label.toLowerCase().indexOf(searchVal);
                            if (idx > -1) {
                                label = [option.label.substring(0, idx), option.label.substring(idx, idx + searchVal.length), option.label.substring(idx + searchVal.length)];
                                filtered.push({'key':option.key, 'label':label});
                            }
                        }
                        if (filtered.length > 0) {
                            $scope.showMenu();
                            $timeout(function() {
                                $scope.filteredOptions = filtered;
                            }, 0.1);
                        }
                    }
                };
                // enable text entry when mouse clicked anywhere in search box
                $element.find('.search-main-area').on('click', function($event) {
                    var target = $($event.target);
                    if (target.is('.search-main-area')) {
                        searchInput.trigger('focus');
                        $scope.showMenu();
                    }
                });
                // when facet clicked, add 1st part of facet and set up options
                $scope.facetClicked = function($index, $event, name) {
                    $scope.hideMenu();
                    var facet = $scope.filteredObj[$index];
                    var label = facet.label;
                    if (Array.isArray(label)) {
                        label = label.join('');
                    }
                    $scope.facetSelected = {'name':facet.name, 'label':[label, '']};
                    if (facet.options !== undefined) {
                        $scope.filteredOptions = $scope.facetOptions = facet.options;
                        $scope.showMenu();
                    }
                    $timeout(function() {
                        searchInput.val('');
                    });
                    $scope.strings.prompt = '';
                    $timeout(function() {
                        searchInput.focus();
                    });
                };
                // when option clicked, complete facet and send event
                $scope.optionClicked = function($index, $event, name) {
                    $scope.hideMenu();
                    var curr = $scope.facetSelected;
                    curr.name = curr.name + '=' + name;
                    curr.label[1] = $scope.filteredOptions[$index].label;
                    if (Array.isArray(curr.label[1])) {
                        curr.label[1] = curr.label[1].join('');
                    }
                    $scope.currentSearch.push(curr);
                    $scope.resetState();
                    $scope.emitQuery();
                    $scope.showMenu();
                };
                // send event with new query string
                $scope.emitQuery = function(removed) {
                    var query = '';
                    for (var i=0; i<$scope.currentSearch.length; i++) {
                        if ($scope.currentSearch[i].name.indexOf('text') !== 0) {
                            if (query.length > 0) query = query + "&";
                            query = query + $scope.currentSearch[i].name;
                        }
                    }
                    if (removed !== undefined && removed.indexOf('text') === 0) {
                        $scope.$emit('textSearch', '', $scope.filter_keys);
                        $scope.textSearch = undefined;
                    }
                    else {
                        $scope.$emit('searchUpdated', query);
                        if ($scope.currentSearch.length > 0) {
                            // prune facets as needed from menus
                            var newFacet = $scope.currentSearch[$scope.currentSearch.length-1].name;
                            var facetParts = newFacet.split('=');
                            angular.forEach($scope.facetsSave, function(facet, idx) {
                                if (facet.name == facetParts[0]) {
                                    if (facet.singleton === true) {
                                        $scope.deleteFacetEntirely(facetParts);
                                    }
                                    else {
                                        $scope.deleteFacetSelection(facetParts);
                                    }
                                }
                            });
                        }
                    }
                };
                // remove facet and either update filter or search
                $scope.removeFacet = function($index, $event) {
                    var removed = $scope.currentSearch[$index].name;
                    $scope.currentSearch.splice($index, 1);
                    if ($scope.facetSelected === undefined) {
                        $scope.emitQuery(removed);
                    }
                    else {
                        $scope.resetState();
                        searchInput.val('');
                    }
                    if ($scope.currentSearch.length === 0) {
                        $scope.strings.prompt = $scope.promptString;
                    }
                    // re-init to restore facets cleanly
                    $scope.facetsObj = $scope.copyFacets($scope.facetsSave);
                    $scope.currentSearch = [];
                    $scope.initFacets();
                };
                // clear entire searchbar
                $scope.clearSearch = function() {
                    if ($scope.currentSearch.length > 0) {
                        $scope.currentSearch = [];
                        $scope.facetsObj = $scope.copyFacets($scope.facetsSave);
                        $scope.resetState();
                        $scope.$emit('searchUpdated', '');
                        $scope.$emit('textSearch', '', $scope.filter_keys);
                    }
                };
                $scope.isMatchLabel = function(label) {
                    return Array.isArray(label);
                };
                $scope.resetState = function() {
                    searchInput.val('');
                    $scope.filteredObj = $scope.facetsObj;
                    $scope.facetSelected = undefined;
                    $scope.facetOptions = undefined;
                    $scope.filteredOptions = undefined;
                    if ($scope.currentSearch.length === 0) {
                        $scope.strings.prompt = $scope.promptString;
                    }
                };
                // showMenu and hideMenu depend on foundation's dropdown. They need
                // to be modified to work with another dropdown implemenation (i.e. bootstrap)
                $scope.showMenu = function() {
                    $timeout(function() {
                        if ($('#facet-drop').hasClass('open') === false && $scope.filteredObj.length > 0) {
                            $('.search-input').trigger('click');
                        }
                    });
                };
                $scope.hideMenu = function() {
                    $(document).foundation('dropdown', 'closeall');
                };
                $scope.initSearch();
            }
        };
    })
;

angular.module('MagicSearchFilterModule', [])
.factory('MagicSearchFilterService', ['$http', function ($http) {
    var matchByFacet =  function(facet, val) {
            if (typeof val === 'string') {
                if ($.inArray(val, facet) > -1 ||
                    $.inArray(val.toLowerCase(), facet) > -1) {
                    return true;
                }
            }
            if (typeof val === 'object') {
                // if object, assume it has valid id or name attribute
                if ($.inArray(val.id, facet) > -1 ||
                    $.inArray(val.name, facet) > -1) {
                    return true;
                }
            }
        };
    var filterByFacet = function(item) {
            // handle special case of empty facet value, match all
            if (this.facet.indexOf("") > -1) {
                return true;
            }
            var val = item[this.key];
            if (val === undefined || val === null) {
                return true;
            }
            if (Array.isArray(val)) {
                for (var i=0; i<val.length; i++) {
                    return matchByFacet(this.facet, val[i]);
                }
            }
            else {
                return matchByFacet(this.facet, val);
            }
        };
    var getItemNamesInFlatString = function(items) {
            var flatString = '';
            angular.forEach(items, function(x) {
                if (x.hasOwnProperty('name')) {
                    flatString += x.name + ' ';
                }
                if (x.hasOwnProperty('res_name')) {
                    flatString += x.res_name + ' ';
                }
            });
            return flatString;
        };
    return {
        /*  Apply facet filtering
         *  to apply text filtering, call searchFilterItems instead
         */
        facetFilterItems: function(query, unfilteredItems) {
            var url = window.location.href;
            if (url.indexOf("?") > -1) {
                query = url.split("?")[1];
            }
            if (query !== undefined && query.length !== 0) {
                // prepare facets by grouping
                var tmp = query.split('&').sort();
                var facets = {};
                angular.forEach(tmp, function(item) {
                    var facet = item.split('=');
                    if (this[facet[0]] === undefined) {
                        this[facet[0]] = [];
                    }
                    this[facet[0]].push(facet[1]);
                }, facets);
                var results = unfilteredItems;
                // filter results
                for (var key in facets) {
                    results = results.filter(filterByFacet, {'facet': facets[key], 'key':key});
                }
                return results;
            }
            else {
                return unfilteredItems.slice();
            }
        },
        /*  Filter items client side based on search criteria.
         */
        searchFilterItems: function(searchFilter, filterKeys, facetItems) {
            var filterText = (searchFilter || '').toLowerCase();
            if (filterText === '') {
                // If the search filter is empty, skip the filtering
                return facetItems;
            }
            // Leverage Array.prototype.filter (ECMAScript 5)
            var filteredItems = facetItems.filter(function(item) {
                for (var i=0; i < filterKeys.length; i++) {  // Can't use $.each or Array.prototype.forEach here
                    var propName = filterKeys[i];
                    var itemProp = item.hasOwnProperty(propName) && item[propName];
                    if (itemProp && typeof itemProp === "string" && 
                        itemProp.toLowerCase().indexOf(filterText) !== -1) {
                        return item;
                    } else if (itemProp && typeof itemProp === "object") {
                        // In case of mutiple values, create a flat string and perform search
                        var flatString = getItemNamesInFlatString(itemProp);
                        if (flatString.toLowerCase().indexOf(filterText) !== -1) {
                            return item;
                        }
                    }
                }
            });
            return filteredItems;
        }
    };
}]);


angular.module('InstancesSelectorModule', ['MagicSearch', 'MagicSearchFilterModule'])
.factory('InstancesFiltersService', ['$http', function ($http) {
    $http.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';
    return {
        getInstancesFilters: function () {
            return $http({
                method: 'GET',
                url: '/elbs/instances/filters'
            }).then(function success (response) {
                var data = response.data || {
                    results: []
                };
                return data.results;
            });
        }
    };
}])
.directive('instanceSelector', [function() {
    return {
        restrict: 'E',
        scope: {
            instanceList: '=',
            instancesLoading: '@'
        },
        templateUrl: '/_template/elbs/instance-selector',
        controller: ['$scope', '$timeout', 'InstancesFiltersService', 'MagicSearchFilterService',
        function ($scope, $timeout, InstancesFiltersService, MagicSearchFilterService) {
            InstancesFiltersService.getInstancesFilters().then(
                function success(result) {
                    $scope.facets = result;
                },
                function error(errData) {
                    eucaHandleError(errData.data.message, errData.status);
                    vm.instancesLoading = false;
                });
            $scope.facets = '[]';
            $scope.state = {'allSelected': false};
            $scope.setAllState = function() {
                $timeout(function() {
                    angular.forEach($scope.instanceList, function(item) {
                        item.selected = $scope.state.allSelected;
                    });
                    if ($scope.state.allSelected) {
                        $scope.selectedInstances = $scope.instanceList;
                    } else {
                        $scope.selectedInstances = [];
                    }
                });
            };
            $scope.handleItemSelection = function() {
                // set all checkbox state based on state of items.selected
                var allItemsCheckbox = document.getElementById('instance-all-checkbox');
                var checkedIems = $scope.instanceList.filter(function (item) {
                    return item.selected;
                });
                if (!checkedIems.length) {
                    $scope.state.allSelected = false;
                }
                // Set indeterminate state on select-all checkbox when checked and at least one item is unselected
                if (allItemsCheckbox) {
                    allItemsCheckbox.indeterminate = !!($scope.state.allSelected && checkedIems.length < $scope.instanceList.length);
                }
                if (!$scope.state.allSelected && checkedIems.length === $scope.instanceList.length) {
                    $scope.state.allSelected = true;
                }
                $scope.selectedInstances = checkedIems;
            };
            $scope.$on('searchUpdated', function ($event, query) {
                $scope.facetFilterItems(query);
            });
            $scope.$on('textSearch', function ($event, text, filterKeys) {
                $scope.searchFilter = text;
                $timeout(function () {
                    $scope.searchFilterItems(filterKeys);
                });
            });
            $scope.facetFilterItems = function(query) {
                $scope.facetInstances = MagicSearchFilterService.facetFilterItems(query, $scope.instanceList);
                $scope.searchFilterItems();
            };
            /*  Filter items client side based on search criteria.
             */
            $scope.searchFilterItems = function(filterKeys) {
                $scope.filteredInstances = MagicSearchFilterService.searchFilterItems($scope.searchFilter, filterKeys, $scope.facetInstances);
            };
            $scope.filteredInstances = $scope.facetInstances = $scope.instanceList;
        }]
    };
}]);

angular.module('ELBCertificateEditorModule', ['ModalModule'])
.directive('certificateEditor', function () {
    return {
        restrict: 'E',
        require: {
            stepData: '?^^stepData'
        },
        scope: {
            certificate: '=ngModel'
        },
        templateUrl: '/_template/elbs/listener-editor/certificate-editor',
        link: function (scope, element, attrs, ctrls) {
            var stepData = ctrls.stepData || {};

            scope.certsAvailable = stepData.certsAvailable;
            scope.policies = stepData.policies;
        },
        controller: ['$scope', 'CertificateService', 'ModalService', function ($scope, CertificateService, ModalService) {
            this.activeTab = 'SSL';
            this.certType = 'existing';

            this.showTab = function (tab) {
                this.activeTab = tab;
            };

            this.chooseSSL = function () {
                $scope.certificate = this.selectedCertificate;
                ModalService.closeModal('certificateEditor');
            };

            this.uploadSSL = function () {
                CertificateService.createCertificate({
                    name: this.name,
                    privateKey: this.privateKey,
                    publicKey: this.publicKey,
                    certificateChain: this.certificateChain
                }).then(function success () {
                    ModalService.closeModal('certificateEditor');
                }, function error () {
                });
            };

            this.submitSSL = function () {
                if($scope.sslCertForm.$invalid) {
                    return;
                }

                if(this.certType === 'existing') {
                    this.chooseSSL();
                } else {
                    this.uploadSSL();
                }
            };

            this.submitBackend = function () {
            };
        }],
        controllerAs: 'ctrl'
    };
})
.directive('ifActive', function () {
    return {
        restrict: 'A',
        require: {
            certificateEditor: '^^certificateEditor',
            ngModel: 'ngModel'
        },
        link: function (scope, element, attrs, ctrls) {
            var certType = attrs.ifActive;
            var required = ctrls.ngModel.$validators.required;

            scope.$watch(function () {
                return ctrls.certificateEditor.certType;
            }, function () {
                ctrls.ngModel.$validate();
            });

            ctrls.ngModel.$validators.required = function (modelValue, viewValue) {
                if(ctrls.certificateEditor.certType !== certType) {
                    return true;
                }

                return required(modelValue, viewValue);
            };
        }
    };
})
.factory('CertificateService', ['$http', function ($http) {
    var svc = {
        getCertificates: function () {
            return $http({
                method: 'GET',
                url: '/certificate'
            }).then(function success (result) {
                return result.data && result.data.message;
            }, function error () {
                return [];
            });
        },

        createCertificate: function (cert) {
            return $http({
                method: 'POST',
                url: '/certificate',
                data: cert
            });
        }
    };

    return svc;
}]);

angular.module('ModalModule', [])
.directive('modal', ['ModalService', '$interpolate', function (ModalService, $interpolate) {
    var template = '<div class="modal-bg" ng-click="closeModal(\'{{modalName}}\')"></div><div class="modal-content">' +
        '<a ng-click="closeModal(\'{{modalName}}\')" class="close-modal"></a><ng-transclude></ng-transclude></div>';
    return {
        restrict: 'A',
        transclude: true,
        compile: function (tElem, tAttrs) {
            var tmp = $interpolate(template)({modalName:tAttrs.modal});
            tElem.append(tmp);
            return function (scope, element, attrs) {
                ModalService.registerModal(attrs.modal, element);

                // Set the height of the containing div based upon the content
                // height of the modal content.
                var el = angular.element(element);
                var content = el.find('.modal-content');

                scope.$watch(function () {
                    return content.height();
                }, function (newVal, oldVal) {
                    if(newVal !== oldVal) {
                        element.height(newVal);
                    }
                });
            };
        },
        controller: ['$scope', function ($scope) {
            $scope.closeModal = function (name) {
                ModalService.closeModal(name);
            };
        }]
    };
}])
.factory('ModalService', ['$rootScope', function ($rootScope) {
    var _modals = {};

    function registerModal (name, element) {
        if(name in _modals) {
            throw new Error('Modal with name ' + name + ' already registered.');
        }
        _modals[name] = element;
    }

    function unregisterModals () {
        for(var i = 0; i < arguments.length; i++ ) {
            var name = arguments[i];
            delete _modals[name];
        }
    }

    function openModal (name) {
        var modal = _modals[name];
        if(!modal) {
            return;
        }
        modal.addClass('open');
        $rootScope.$broadcast('modal:open', name);
    }

    function closeModal (name) {
        var modal = _modals[name];
        if(!modal) {
            return;
        }

        modal.removeClass('open');
        $rootScope.$broadcast('modal:close', name);
    }

    function _getModals () {
        return _modals;
    }

    function _clearModals () {
        _modals = {};
    }

    return {
        openModal: openModal,
        closeModal: closeModal,
        registerModal: registerModal,
        unregisterModals: unregisterModals,
        _getModals: _getModals,
        _clearModals: _clearModals
    };
}]);

angular.module('TagEditorModule', ['EucaConsoleUtils'])
    .directive('tagEditor', ['eucaUnescapeJson', function (eucaUnescapeJson) {
        return {
            scope: {
                showNameTag: '@',
                autoscale: '@'
            },
            transclude: true,
            restrict: 'E',
            require: 'ngModel',
            templateUrl: '/_template/tag-editor/tag-editor',
            controller: ['$scope', '$window', function ($scope, $window) {
                $scope.newTagKey = '';
                $scope.newTagValue = '';

                $scope.$watch('newTagKey', requireOther('newTagValue'));
                $scope.$watch('newTagValue', requireOther('newTagKey'));

                function requireOther (other) {
                    return function (newVal) {
                        if(newVal === '' || $scope[other] === '') {
                            $scope.tagForm.$setPristine();
                        }
                    };
                }

                $scope.addTag = function ($event) {
                    $event.preventDefault();

                    if($scope.newTagKey === '' || $scope.newTagValue === '') {
                        return;
                    }

                    if($scope.tagForm.$invalid || $scope.tagForm.$pristine) {
                        return;
                    }

                    var tag = {
                        name: $scope.newTagKey,
                        value: $scope.newTagValue,
                    };

                    if($scope.autoscale) {
                        tag.propagate_at_launch = !!$scope.newTagPropagate;
                    }

                    $scope.tags.push(tag);

                    resetForm();
                    $scope.$emit('tagUpdate');
                };

                $scope.removeTag = function ($index) {
                    $scope.tags.splice($index, 1);
                    $scope.$emit('tagUpdate');
                };

                var containsKey = function (collection, key) {
                    return collection.some(function (current) {
                        return current.name === key;
                    });
                };

                var resetForm = function () {
                    $scope.newTagKey = '';
                    $scope.newTagValue = '';
                    $scope.newTagPropagate= false;
                    $scope.tagForm.key.$setPristine();
                    $scope.tagForm.key.$setUntouched();
                    $scope.tagForm.value.$setPristine();
                    $scope.tagForm.value.$setUntouched();
                    $scope.tagForm.$setPristine();
                    $scope.tagForm.$setUntouched();
                };
            }],
            link: function (scope, element, attrs, ctrl, transcludeContents) {
                var content = transcludeContents();
                var tags = JSON.parse(content.text() || '[]');
                scope.tags = tags.filter(function (current) {
                    return !current.name.match(/^aws:.*/) &&
                        !current.name.match(/^euca:.*/);
                });

                attrs.showNameTag = attrs.showNameTag !== 'false';
                attrs.autoscale = !!attrs.autoscale;    // default to false

                scope.updateViewValue = function () {
                    ctrl.$setViewValue(scope.tags);
                };
                ctrl.$setViewValue(scope.tags);
            }
        };
    }])
    .directive('tagName', function () {
        var validPattern = /^(?!aws:)(?!euca:).{0,128}$/;
        return {
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                ctrl.$validators.tagName = function (modelValue, viewValue) {
                    return validPattern.test(viewValue);
                };
            }
        };
    })
    .directive('tagValue', function () {
        var validPattern = /^(?!aws:).{0,256}$/;
        return {
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                ctrl.$validators.tagValue = function (modelValue, viewValue) {
                    return validPattern.test(viewValue);
                };
            }
        };
    })
    .directive('preventDuplicates', function () {
        return {
            require: 'ngModel',
            restrict: 'A',
            link: function (scope, element, attrs, ctrl) {
                ctrl.$validators.preventDuplicates = function (modelValue, viewValue) {
                    return !scope.tags.some(function (current) {
                        return viewValue === current.name;
                    });
                };
            }
        };
    })
    .filter('safe', ['$sanitize', function ($sanitize) {
        return function (tag) {
            return $sanitize(tag.name + ' = ' + tag.value);
        };
    }]);

//# sourceMappingURL=elb-wizard.js.map